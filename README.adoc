== The Legacy App

This legacy app is a stereotypical monolith, with legacy code
that nobody loves. It has an anemic structure. We've left just
one domain which is the `CustomerRentalHistory`. It will call this API
https://stripe.com/docs/api/java#list_charges

== The script

=== The Legacy App

==== The Legacy App Introduction

Set up a scenario. We have a problem with a legacy service. Let’s see how
Spring Cloud Contract can solve this. The legacy app is the stripe.com API,
fronting a mainframe, it offers many API’s one of which is the `CustomerRentalHistory`
API returns JSON response containing lots of fields about the customer including
their name / address / and how many rentals they have made in the past. For simplicity sake
we're returning last 25 charges.

A explains the legacy API (https://stripe.com/docs/api/java#list_charges)
to M and talks through the kind of problems he has seen with
the API & which fields he only cares about. `Amount`, `Captured`, `Customer`
A provides a tour of the client side code which currently exists to call the
`CustomerRentalHistory` service.

==== The Legacy App Contract

M steps in takes over the keyboard and show A how to write a contract
test to generate a stub for the rental service A asks questions to clarify
and reinforce what M is doing.

- We don't want to fake the response manually cause we
want to verify the integrations
* how can we do that?
* who knows WireMock?
- In `stubs`
* we add `spring-cloud-contract-maven-plugin` section
* we add the `<skipTests>true</skipTests>` cause we don't want to run tests
* we add the `starter-verifier` dependency
* we write the first contract that returns the contents of the `charges.json`
* when we do `./mvnw clean install -pl the-legacy-app-stubs` we will see that stubs
got created
- In `impl`
* we write a test that asserts that the response contains 25 results
* we run it - will it pass? Of course not...
* we add `spring-cloud-starter-contract-stubrunner`
* we write a test that uses `@AutoConfigureStubRunner` and works offline to download stubs
* we assert that the response contains 25 results

==== The Legacy Summary

At the end of the session

- A’s code base has an extra contract test in it
- The maven plugin has been added to the project
- The contract is in the client side code base
* we create a submodule with `src/test/resources/contracts`
* setup maven plugin to first generate tests (which will fail)
* then we set the maven plugin NOT to generate tests, only
generate stubs because we don’t own the production code those stubs will be reused in the stub runner tests
- A test with StubRunner has been written and executed
- The producer side test has not been executed at this point

=== External contracts

=== External contracts introduction

A then asks where the producer test should live.
A says he is good friends with the developers of the bad API
and A builds a pull request for A’s git repo which
has the contracts in it and demonstrates how A can
integrate the app into the tests. Explain that ones the
contracts are validated against the producer then we're talking
about *producer contracts*.

M says how to move the contracts to an external repository
it happens that we already have one prepared here:

```
$ git clone https://github.com/marcingrzejszczak/2017-s1p-external-contracts.git
```

M explains the structure:

- contracts lay under `main` cause we need to build the JAR with contracts
- explain the assembly plugin
- each application has its own slash separated `groupid`/`artifactid` folder
structure
* under that folder it's good practice for each consumer to their own subfolder
* we don't want to run tests here (that's why we skip them)

=== External contracts coding

Time for action:

- we create the missing `src/main/resources/com/example/customer-rental-history` folder
- we set up the `pom.xml` for `customer-rental-history` contracts (copy it from `done` folder)
- we do `mvn clean install` to install the stubs locally and update the tests in the IDE
to point to these stubs
- we've proven that we can run tests locally against the stubs from the contract
- we `cd` back to root and do `./mvnw clean install` - we show the JAR with all contracts

=== External contracts summary

At the end of the session

- A separate, single repository with all the contracts got created
- A’s code base no longer uses the contracts from the stub module
cause the stubs come from the external repo
* That will work only under the assumption that the `CustomerRentalHistory`
team will start doing contract testing
- Now, all teams can store contracts in that repository and collaborate
- We're ready to make `the legacy application` test its own API

=== External contracts